<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Typing Piano Drop</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      background: radial-gradient(circle at top, #1f2933, #020617);
      color: #f9fafb;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
    }

    .wrapper {
      max-width: 960px;
      width: 100%;
      background: rgba(15, 23, 42, 0.95);
      border-radius: 24px;
      box-shadow: 0 24px 70px rgba(0, 0, 0, 0.6);
      padding: 20px;
      display: grid;
      grid-template-columns: minmax(0, 2fr) minmax(0, 1.2fr);
      gap: 16px;
    }

    @media (max-width: 800px) {
      .wrapper {
        grid-template-columns: 1fr;
      }
    }

    .left {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .right {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    h1 {
      font-size: 1.4rem;
      font-weight: 700;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: #e5e7eb;
    }

    .subtitle {
      font-size: 0.9rem;
      color: #9ca3af;
    }

    .controls-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    select, button {
      border-radius: 999px;
      border: none;
      padding: 8px 14px;
      font-size: 0.9rem;
      cursor: pointer;
    }

    select {
      background: #020617;
      color: #e5e7eb;
      border: 1px solid #374151;
    }

    button {
      background: #22c55e;
      color: #022c22;
      font-weight: 600;
      transition: transform 0.08s ease, box-shadow 0.08s ease, filter 0.08s ease;
      box-shadow: 0 6px 18px rgba(34, 197, 94, 0.35);
    }

    button:hover {
      transform: translateY(-1px);
      filter: brightness(1.06);
    }

    button:active {
      transform: translateY(0);
      box-shadow: 0 3px 10px rgba(34, 197, 94, 0.25);
    }

    button.secondary {
      background: transparent;
      color: #9ca3af;
      border: 1px solid #374151;
      box-shadow: none;
    }

    .status-bar {
      display: flex;
      justify-content: space-between;
      font-size: 0.85rem;
      color: #9ca3af;
      flex-wrap: wrap;
      row-gap: 4px;
    }

    .status-bar span strong {
      color: #e5e7eb;
    }

    .canvas-container {
      border-radius: 18px;
      overflow: hidden;
      border: 1px solid #111827;
      background: linear-gradient(to bottom, #020617, #020617);
    }

    #gameCanvas {
      display: block;
      width: 100%;
      height: 420px;
      background: radial-gradient(circle at top, #020617, #020617);
    }

    .input-panel {
      background: #020617;
      border-radius: 18px;
      padding: 12px 14px;
      border: 1px solid #111827;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .input-label {
      font-size: 0.8rem;
      color: #9ca3af;
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }

    .typing-display {
      font-size: 1.2rem;
      padding: 6px 10px;
      border-radius: 999px;
      background: #020617;
      border: 1px solid #374151;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .typing-text {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex: 1;
    }

    .cursor {
      width: 2px;
      height: 1.2em;
      background: #22c55e;
      animation: blink 1s steps(1) infinite;
      margin-left: 4px;
    }

    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }

    .hint {
      font-size: 0.8rem;
      color: #6b7280;
    }

    .judgement-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.9rem;
      margin-top: 4px;
    }

    #judgementLabel {
      font-weight: 600;
    }

    #comboLabel {
      color: #9ca3af;
    }

    .level-editor-hint {
      font-size: 0.8rem;
      color: #9ca3af;
      line-height: 1.5;
      background: #020617;
      border-radius: 18px;
      border: 1px dashed #374151;
      padding: 10px 12px;
    }

    code {
      font-family: "JetBrains Mono", "Fira Code", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.78rem;
      background: #020617;
      padding: 2px 4px;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <div class="left">
      <div>
        <h1>Typing Piano Drop</h1>
        <p class="subtitle">Type the words on the falling tiles before they hit the line. Each correct word plays a note.</p>
      </div>

      <div class="controls-row">
        <select id="levelSelect"></select>
        <button id="startBtn">Start</button>
        <button id="pauseBtn" class="secondary">Pause</button>
      </div>

      <div class="status-bar">
        <span>Score: <strong id="scoreDisplay">0</strong></span>
        <span>Misses: <strong id="missDisplay">0</strong></span>
        <span>Speed: <strong id="speedDisplay">Normal</strong></span>
        <span>Max Combo: <strong id="maxComboDisplay">0x</strong></span>
      </div>

      <div class="canvas-container">
        <canvas id="gameCanvas" width="600" height="420"></canvas>
      </div>
    </div>

    <div class="right">
      <div class="input-panel">
        <div class="input-label">Your typing</div>
        <div class="typing-display">
          <div class="typing-text" id="typingText"></div>
          <div class="cursor"></div>
        </div>
        <div class="judgement-row">
          <span id="judgementLabel">Ready</span>
          <span id="comboLabel">Combo: 0x</span>
        </div>
        <div class="hint">
          Type letters and press <strong>Space</strong> or <strong>Enter</strong> to submit.<br />
          Hit tiles just before they cross the bottom line for <strong>Perfect</strong> timing.
        </div>
      </div>

      <div class="level-editor-hint">
        <strong>Editing levels & notes</strong><br />
        Open <code>index.html</code> and look for the <code>LEVELS</code> array in the script.<br />
        Each tile is:<br />
        <code>{ time: seconds, word: "text", note: "C4" }</code><br />
        Add, remove or change entries to create your own songs.
      </div>
    </div>
  </div>

  <script>
    /**********************************************************
     * 1. CONFIGURATION: LEVELS & NOTES
     **********************************************************/

    const NOTE_FREQUENCIES = {
      "C4": 261.63,
      "D4": 293.66,
      "E4": 329.63,
      "F4": 349.23,
      "G4": 392.00,
      "A4": 440.00,
      "B4": 493.88,
      "C5": 523.25
    };

    const LEVELS = [
      {
        id: "demo1",
        name: "Warmup (slow)",
        fallDuration: 4.5,
        tiles: [
          { time: 1.0, word: "la",     note: "C4" },
          { time: 2.5, word: "la",     note: "D4" },
          { time: 4.0, word: "la",     note: "E4" },
          { time: 5.5, word: "play",   note: "G4" },
          { time: 7.0, word: "music",  note: "C5" },
          { time: 9.0, word: "type",   note: "E4" },
          { time: 11.0, word: "piano", note: "G4" }
        ]
      },
      {
        id: "flow1",
        name: "Long Practice – Flow",
        fallDuration: 3.8,
        tiles: [
          { time: 1.0,  word: "type",   note: "C4" },
          { time: 1.8,  word: "flow",   note: "D4" },
          { time: 2.6,  word: "beat",   note: "E4" },
          { time: 3.4,  word: "time",   note: "G4" },
          { time: 4.2,  word: "keys",   note: "A4" },
          { time: 5.0,  word: "rhythm", note: "G4" },

          { time: 6.0,  word: "type",   note: "C4" },
          { time: 6.8,  word: "type",   note: "D4" },
          { time: 7.6,  word: "type",   note: "E4" },
          { time: 8.4,  word: "go",     note: "G4" },
          { time: 9.2,  word: "fast",   note: "A4" },
          { time: 10.0, word: "now",    note: "G4" },

          { time: 11.0, word: "left",   note: "E4" },
          { time: 11.8, word: "right",  note: "D4" },
          { time: 12.6, word: "up",     note: "C4" },
          { time: 13.4, word: "down",   note: "E4" },
          { time: 14.2, word: "jump",   note: "G4" },
          { time: 15.0, word: "tap",    note: "A4" },

          { time: 16.0, word: "focus",  note: "C4" },
          { time: 16.8, word: "stay",   note: "D4" },
          { time: 17.6, word: "in",     note: "E4" },
          { time: 18.4, word: "the",    note: "F4" },
          { time: 19.2, word: "zone",   note: "G4" },
          { time: 20.0, word: "now",    note: "A4" },

          { time: 21.0, word: "home",   note: "E4" },
          { time: 21.8, word: "row",    note: "D4" },
          { time: 22.6, word: "asdf",   note: "C4" },
          { time: 23.4, word: "jkl;",   note: "E4" },
          { time: 24.2, word: "type",   note: "G4" },
          { time: 25.0, word: "smooth", note: "A4" },

          { time: 26.0, word: "flow",   note: "C4" },
          { time: 26.8, word: "flow",   note: "D4" },
          { time: 27.6, word: "flow",   note: "E4" },
          { time: 28.4, word: "more",   note: "G4" },
          { time: 29.2, word: "more",   note: "A4" },
          { time: 30.0, word: "done",   note: "C5" }
        ]
      },
      {
        id: "arpeggio1",
        name: "Long Practice – Arpeggios",
        fallDuration: 3.2,
        tiles: [
          { time: 0.8,  word: "do",   note: "C4" },
          { time: 1.4,  word: "mi",   note: "E4" },
          { time: 2.0,  word: "so",   note: "G4" },
          { time: 2.6,  word: "do",   note: "C5" },

          { time: 3.4,  word: "re",   note: "D4" },
          { time: 4.0,  word: "fa",   note: "F4" },
          { time: 4.6,  word: "la",   note: "A4" },
          { time: 5.2,  word: "re",   note: "D4" },

          { time: 6.0,  word: "up",   note: "C4" },
          { time: 6.6,  word: "up",   note: "E4" },
          { time: 7.2,  word: "up",   note: "G4" },
          { time: 7.8,  word: "up",   note: "C5" },

          { time: 8.6,  word: "down", note: "C5" },
          { time: 9.2,  word: "down", note: "G4" },
          { time: 9.8,  word: "down", note: "E4" },
          { time: 10.4, word: "down", note: "C4" },

          { time: 11.2, word: "roll", note: "E4" },
          { time: 11.8, word: "roll", note: "G4" },
          { time: 12.4, word: "roll", note: "C5" },
          { time: 13.0, word: "rest", note: "D4" },

          { time: 14.0, word: "fast", note: "C4" },
          { time: 14.6, word: "fast", note: "E4" },
          { time: 15.2, word: "fast", note: "G4" },
          { time: 15.8, word: "fast", note: "C5" },

          { time: 16.6, word: "clean", note: "A4" },
          { time: 17.2, word: "clean", note: "G4" },
          { time: 17.8, word: "clean", note: "E4" },
          { time: 18.4, word: "clean", note: "C4" },

          { time: 19.4, word: "final", note: "D4" },
          { time: 20.0, word: "run",   note: "F4" },
          { time: 20.6, word: "run",   note: "A4" },
          { time: 21.2, word: "run",   note: "C5" },

          { time: 22.0, word: "done",  note: "C5" },
          { time: 22.6, word: "gg",    note: "G4" },
          { time: 23.2, word: "wp",    note: "E4" },
          { time: 23.8, word: "rest",  note: "C4" }
        ]
      }
    ];

    /**********************************************************
     * 2. AUDIO (Web Audio API)
     **********************************************************/
    let audioCtx = null;

    function ensureAudioContext() {
      if (!audioCtx) {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AudioContext();
      }
    }

    function playNote(noteName, durationSeconds = 0.35) {
      ensureAudioContext();
      const freq = NOTE_FREQUENCIES[noteName] || 440;
      const osc = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();

      osc.type = "sine";
      osc.frequency.value = freq;

      osc.connect(gainNode);
      gainNode.connect(audioCtx.destination);

      const now = audioCtx.currentTime;
      gainNode.gain.setValueAtTime(0.18, now);
      gainNode.gain.exponentialRampToValueAtTime(0.0001, now + durationSeconds);

      osc.start(now);
      osc.stop(now + durationSeconds + 0.05);
    }

    /**********************************************************
     * 3. GAME STATE
     **********************************************************/
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const scoreDisplay = document.getElementById("scoreDisplay");
    const missDisplay = document.getElementById("missDisplay");
    const speedDisplay = document.getElementById("speedDisplay");
    const maxComboDisplay = document.getElementById("maxComboDisplay");
    const typingTextEl = document.getElementById("typingText");
    const levelSelect = document.getElementById("levelSelect");
    const startBtn = document.getElementById("startBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const judgementLabel = document.getElementById("judgementLabel");
    const comboLabel = document.getElementById("comboLabel");

    let currentLevel = LEVELS[0];
    let startTime = null;
    let paused = false;
    let pauseOffset = 0;
    let pauseStartTime = null;

    let activeTiles = [];
    let remainingTiles = [];
    let score = 0;
    let misses = 0;
    let combo = 0;
    let maxCombo = 0;
    let lastGameTime = 0;

    const tileWidth = 150;
    const tileHeight = 40;
    const bottomLineY = canvas.height - 40;

    const laneCount = 4;
    let laneMissStacks = new Array(laneCount).fill(0);
    const MAX_STACK_HEIGHT = 6; // max red tiles per lane before fail

    // Game over state
    let gameOver = false;
    let gameOverTime = 0;

    // Confetti
    let confettiPieces = [];

    /**********************************************************
     * 4. INITIALIZATION
     **********************************************************/
    function populateLevelSelect() {
      LEVELS.forEach((level, index) => {
        const opt = document.createElement("option");
        opt.value = level.id;
        opt.textContent = level.name;
        if (index === 0) opt.selected = true;
        levelSelect.appendChild(opt);
      });
    }

    function resetGame(level) {
      currentLevel = level || currentLevel;
      startTime = null;
      pauseOffset = 0;
      pauseStartTime = null;
      paused = false;
      lastGameTime = 0;
      gameOver = false;
      gameOverTime = 0;
      confettiPieces = [];

      activeTiles = [];
      remainingTiles = currentLevel.tiles
        .map(t => ({ ...t, spawned: false }))
        .sort((a, b) => a.time - b.time);

      score = 0;
      misses = 0;
      combo = 0;
      maxCombo = 0;
      laneMissStacks = new Array(laneCount).fill(0);

      updateTypingDisplay();
      updateStatusDisplays();
      setJudgement("Ready", "#e5e7eb");

      speedDisplay.textContent =
        currentLevel.fallDuration <= 3 ? "Fast" :
        currentLevel.fallDuration >= 4.5 ? "Slow" :
        "Normal";

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawFrame(0);
    }

    populateLevelSelect();
    resetGame(LEVELS[0]);

    /**********************************************************
     * 5. GAME LOOP
     **********************************************************/
    function getGameTimeSeconds(timestamp) {
      if (startTime === null) return 0;
      return (timestamp - startTime - pauseOffset) / 1000;
    }

    function spawnTiles(gameTime) {
      while (!gameOver && remainingTiles.length > 0 && remainingTiles[0].time <= gameTime) {
        const base = remainingTiles.shift();
        const laneIndex = activeTiles.length % laneCount;
        const laneWidth = canvas.width / laneCount;
        const x = laneIndex * laneWidth + (laneWidth - tileWidth) / 2;

        activeTiles.push({
          word: base.word,
          note: base.note,
          spawnTime: gameTime,
          x,
          y: -tileHeight,
          laneIndex,
          hit: false,
          missed: false,
          state: "falling",   // "falling" | "hitPopping" | "missedStatic" | "done"
          effectProgress: 0
        });
      }
    }

    function triggerGameOver() {
      if (gameOver) return;
      gameOver = true;
      gameOverTime = lastGameTime;
      combo = 0;
      setJudgement("Game Over", "#f97373");
      updateStatusDisplays();
    }

    function handleMiss(tile) {
      if (tile.missed) return;
      tile.missed = true;
      tile.state = "missedStatic";

      const li = tile.laneIndex;
      const stackIndex = laneMissStacks[li];
      laneMissStacks[li] = stackIndex + 1;

      tile.y = bottomLineY - tileHeight * (stackIndex + 1);

      misses += 1;
      combo = 0;
      setJudgement("Miss", "#f97373");
      updateStatusDisplays();

      if (laneMissStacks[li] >= MAX_STACK_HEIGHT) {
        triggerGameOver();
      }
    }

    function updateTiles(gameTime, delta) {
      const duration = currentLevel.fallDuration;

      activeTiles.forEach(tile => {
        if (tile.state === "falling") {
          const t = Math.max(0, Math.min(1, (gameTime - tile.spawnTime) / duration));
          tile.y = t * (bottomLineY - tileHeight);

          if (!tile.hit && !tile.missed && tile.y + tileHeight >= bottomLineY + 2) {
            handleMiss(tile);
          }
        } else if (tile.state === "hitPopping") {
          tile.effectProgress += delta;
          const p = Math.min(tile.effectProgress / 0.4, 1);
          tile.y -= delta * 40;
          if (p >= 1) {
            tile.state = "done";
          }
        }
        // missedStatic: do nothing (stay stacked)
      });

      activeTiles = activeTiles.filter(tile => tile.state !== "done");
    }

    function spawnConfetti(x, y, count = 16) {
      const colors = [
        [244, 63, 94],   // pink
        [59, 130, 246],  // blue
        [234, 179, 8],   // yellow
        [16, 185, 129]   // teal
      ];

      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 160 + Math.random() * 140;
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed - 60;
        const size = 4 + Math.random() * 4;
        const ttl = 0.6 + Math.random() * 0.4;
        const color = colors[Math.floor(Math.random() * colors.length)];

        confettiPieces.push({
          x,
          y,
          vx,
          vy,
          size,
          ttl,
          life: 0,
          color,
          rotation: Math.random() * Math.PI,
          rotationSpeed: (Math.random() - 0.5) * 8
        });
      }
    }

    function updateConfetti(delta) {
      const gravity = 400;
      confettiPieces.forEach(p => {
        p.life += delta;
        p.x += p.vx * delta;
        p.y += p.vy * delta;
        p.vy += gravity * delta;
        p.rotation += p.rotationSpeed * delta;
      });
      confettiPieces = confettiPieces.filter(p => p.life < p.ttl);
    }

    function drawFrame(gameTime) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.save();

      // Screen shake on game over
      if (gameOver) {
        const t = Math.max(0, lastGameTime - gameOverTime);
        const shakeDuration = 0.5;
        if (t < shakeDuration) {
          const intensity = (1 - t / shakeDuration) * 8;
          const shakeX = (Math.random() * 2 - 1) * intensity;
          const shakeY = (Math.random() * 2 - 1) * intensity;
          ctx.translate(shakeX, shakeY);
        }
      }

      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, "#020617");
      gradient.addColorStop(1, "#020617");
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Bottom "hit line"
      ctx.strokeStyle = "#4b5563";
      ctx.lineWidth = 2;
      ctx.setLineDash([6, 6]);
      ctx.beginPath();
      ctx.moveTo(0, bottomLineY);
      ctx.lineTo(canvas.width, bottomLineY);
      ctx.stroke();
      ctx.setLineDash([]);

      // Tiles
      activeTiles.forEach(tile => {
        let baseColor = [34, 197, 94]; // green
        let fillAlpha = 0.2;
        let borderAlpha = 0.7;

        if (tile.missed && !tile.hit) {
          baseColor = [239, 68, 68]; // red
          fillAlpha = 0.45;
          borderAlpha = 0.95;
        } else if (tile.hit) {
          baseColor = [34, 197, 94];
          fillAlpha = 0.4;
          borderAlpha = 0.95;
        }

        let scale = 1;
        let fadeAlpha = 1;

        if (tile.state === "hitPopping") {
          const p = Math.min(tile.effectProgress / 0.4, 1);
          scale = 1 + 0.4 * p;
          fadeAlpha = 1 - p;
        }

        const x = tile.x;
        const y = tile.y;
        const w = tileWidth;
        const h = tileHeight;
        const centerX = x + w / 2;
        const centerY = y + h / 2;
        const radius = 10;

        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.scale(scale, scale);
        ctx.translate(-centerX, -centerY);

        ctx.fillStyle = `rgba(${baseColor[0]}, ${baseColor[1]}, ${baseColor[2]}, ${fillAlpha * fadeAlpha})`;
        ctx.strokeStyle = `rgba(${baseColor[0]}, ${baseColor[1]}, ${baseColor[2]}, ${borderAlpha * fadeAlpha})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + w - radius, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
        ctx.lineTo(x + w, y + h - radius);
        ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
        ctx.lineTo(x + radius, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = "#e5e7eb";
        ctx.font = "bold 16px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(tile.word, x + w / 2, y + h / 2);

        ctx.restore();
      });

      // Confetti
      confettiPieces.forEach(p => {
        const alpha = 1 - p.life / p.ttl;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rotation);
        ctx.fillStyle = `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, ${alpha})`;
        ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size * 0.6);
        ctx.restore();
      });

      // Game over overlay
      if (gameOver) {
        const t = Math.max(0, lastGameTime - gameOverTime);
        const maxAlpha = 0.65;
        const alpha = Math.min(maxAlpha, 0.3 + t * 0.5);
        ctx.fillStyle = `rgba(239,68,68,${alpha})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "rgba(15,23,42,0.9)";
        ctx.font = "bold 36px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2 - 10);

        ctx.font = "16px system-ui";
        ctx.fillStyle = "rgba(249,250,251,0.9)";
        ctx.fillText("Press Start to try again", canvas.width / 2, canvas.height / 2 + 22);
      }

      ctx.restore();
    }

    function gameLoop(timestamp) {
      if (paused) {
        requestAnimationFrame(gameLoop);
        return;
      }

      if (startTime === null) {
        startTime = timestamp;
        lastGameTime = 0;
      }

      const gameTime = getGameTimeSeconds(timestamp);
      const delta = Math.max(0, gameTime - lastGameTime);
      lastGameTime = gameTime;

      if (!gameOver) {
        spawnTiles(gameTime);
        updateTiles(gameTime, delta);
      }

      updateConfetti(delta);
      drawFrame(gameTime);

      requestAnimationFrame(gameLoop);
    }

    /**********************************************************
     * 6. INPUT & SCORING
     **********************************************************/
    let currentInput = "";

    function updateTypingDisplay() {
      typingTextEl.textContent = currentInput;
    }

    function setJudgement(text, color) {
      judgementLabel.textContent = text;
      judgementLabel.style.color = color || "#e5e7eb";
    }

    function updateStatusDisplays() {
      scoreDisplay.textContent = score;
      missDisplay.textContent = misses;
      comboLabel.textContent = `Combo: ${combo}x`;
      maxComboDisplay.textContent = `${maxCombo}x`;
    }

    function submitInput() {
      if (gameOver) {
        setJudgement("Game Over", "#f97373");
        return;
      }

      const word = currentInput.trim().toLowerCase();
      if (!word) return;
      currentInput = "";
      updateTypingDisplay();

      let bestTile = null;
      let bestDist = Infinity;

      activeTiles.forEach(tile => {
        if (tile.hit || tile.missed || tile.state !== "falling") return;
        if (tile.word.toLowerCase() !== word) return;
        const dist = Math.abs((tile.y + tileHeight) - bottomLineY);
        if (dist < bestDist) {
          bestDist = dist;
          bestTile = tile;
        }
      });

      if (bestTile) {
        // Timing judgement
        let judgement = "Good";
        let basePoints = 50;
        let color = "#fde68a";

        if (bestDist <= 10) {
          judgement = "Perfect";
          basePoints = 100;
          color = "#4ade80";
        } else if (bestDist <= 25) {
          judgement = "Great";
          basePoints = 70;
          color = "#a5b4fc";
        } else if (bestDist > 45) {
          judgement = "Late";
          basePoints = 30;
          color = "#fbbf24";
        }

        bestTile.hit = true;
        bestTile.state = "hitPopping";
        bestTile.effectProgress = 0;

        combo += 1;
        if (combo > maxCombo) maxCombo = combo;

        const multiplier = 1 + (combo - 1) * 0.1;
        const gained = Math.round(basePoints * multiplier);
        score += gained;

        setJudgement(`${judgement} (+${gained})`, color);
        playNote(bestTile.note);
        spawnConfetti(bestTile.x + tileWidth / 2, bestTile.y + tileHeight / 2, 22);
        updateStatusDisplays();
      } else {
        setJudgement("No match", "#9ca3af");
      }
    }

    window.addEventListener("keydown", (e) => {
      if (e.metaKey || e.ctrlKey || e.altKey) return;

      if (e.key === "Backspace") {
        e.preventDefault();
        currentInput = currentInput.slice(0, -1);
        updateTypingDisplay();
        return;
      }

      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        submitInput();
        return;
      }

      if (e.key.length === 1) {
        currentInput += e.key;
        updateTypingDisplay();
      }
    });

    /**********************************************************
     * 7. BUTTONS & LEVEL CHANGE
     **********************************************************/
    startBtn.addEventListener("click", () => {
      ensureAudioContext();
      resetGame(currentLevel);
      requestAnimationFrame(gameLoop);
    });

    pauseBtn.addEventListener("click", () => {
      if (!startTime) return;

      if (!paused) {
        paused = true;
        pauseStartTime = performance.now();
        pauseBtn.textContent = "Resume";
      } else {
        paused = false;
        if (pauseStartTime !== null) {
          const now = performance.now();
          pauseOffset += now - pauseStartTime;
        }
        pauseStartTime = null;
        pauseBtn.textContent = "Pause";
      }
    });

    levelSelect.addEventListener("change", (e) => {
      const id = e.target.value;
      const level = LEVELS.find(l => l.id === id);
      if (level) {
        resetGame(level);
      }
    });
  </script>
</body>
</html>
