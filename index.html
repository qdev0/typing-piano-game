<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Typing Piano Drop</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      background: radial-gradient(circle at top, #1f2933, #020617);
      color: #f9fafb;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
    }

    .wrapper {
      max-width: 960px;
      width: 100%;
      background: rgba(15, 23, 42, 0.95);
      border-radius: 24px;
      box-shadow: 0 24px 70px rgba(0, 0, 0, 0.6);
      padding: 20px;
      display: grid;
      grid-template-columns: minmax(0, 2fr) minmax(0, 1.2fr);
      gap: 16px;
    }

    @media (max-width: 800px) {
      .wrapper {
        grid-template-columns: 1fr;
      }
    }

    .left {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .right {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    h1 {
      font-size: 1.4rem;
      font-weight: 700;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: #e5e7eb;
    }

    .subtitle {
      font-size: 0.9rem;
      color: #9ca3af;
    }

    .controls-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    select, button {
      border-radius: 999px;
      border: none;
      padding: 8px 14px;
      font-size: 0.9rem;
      cursor: pointer;
    }

    select {
      background: #020617;
      color: #e5e7eb;
      border: 1px solid #374151;
    }

    button {
      background: #22c55e;
      color: #022c22;
      font-weight: 600;
      transition: transform 0.08s ease, box-shadow 0.08s ease, filter 0.08s ease;
      box-shadow: 0 6px 18px rgba(34, 197, 94, 0.35);
    }

    button:hover {
      transform: translateY(-1px);
      filter: brightness(1.06);
    }

    button:active {
      transform: translateY(0);
      box-shadow: 0 3px 10px rgba(34, 197, 94, 0.25);
    }

    button.secondary {
      background: transparent;
      color: #9ca3af;
      border: 1px solid #374151;
      box-shadow: none;
    }

    .status-bar {
      display: flex;
      justify-content: space-between;
      font-size: 0.85rem;
      color: #9ca3af;
    }

    .status-bar span strong {
      color: #e5e7eb;
    }

    .canvas-container {
      border-radius: 18px;
      overflow: hidden;
      border: 1px solid #111827;
      background: linear-gradient(to bottom, #020617, #020617);
    }

    #gameCanvas {
      display: block;
      width: 100%;
      height: 420px;
      background: radial-gradient(circle at top, #020617, #020617);
    }

    .input-panel {
      background: #020617;
      border-radius: 18px;
      padding: 12px 14px;
      border: 1px solid #111827;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .input-label {
      font-size: 0.8rem;
      color: #9ca3af;
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }

    .typing-display {
      font-size: 1.2rem;
      padding: 6px 10px;
      border-radius: 999px;
      background: #020617;
      border: 1px solid #374151;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .typing-text {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex: 1;
    }

    .cursor {
      width: 2px;
      height: 1.2em;
      background: #22c55e;
      animation: blink 1s steps(1) infinite;
      margin-left: 4px;
    }

    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }

    .hint {
      font-size: 0.8rem;
      color: #6b7280;
    }

    .level-editor-hint {
      font-size: 0.8rem;
      color: #9ca3af;
      line-height: 1.5;
      background: #020617;
      border-radius: 18px;
      border: 1px dashed #374151;
      padding: 10px 12px;
    }

    code {
      font-family: "JetBrains Mono", "Fira Code", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.78rem;
      background: #020617;
      padding: 2px 4px;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <div class="left">
      <div>
        <h1>Typing Piano Drop</h1>
        <p class="subtitle">Type the words on the falling tiles before they hit the line. Each correct word plays a note.</p>
      </div>

      <div class="controls-row">
        <select id="levelSelect"></select>
        <button id="startBtn">Start</button>
        <button id="pauseBtn" class="secondary">Pause</button>
      </div>

      <div class="status-bar">
        <span>Score: <strong id="scoreDisplay">0</strong></span>
        <span>Misses: <strong id="missDisplay">0</strong></span>
        <span>Speed: <strong id="speedDisplay">Normal</strong></span>
      </div>

      <div class="canvas-container">
        <canvas id="gameCanvas" width="600" height="420"></canvas>
      </div>
    </div>

    <div class="right">
      <div class="input-panel">
        <div class="input-label">Your typing</div>
        <div class="typing-display">
          <div class="typing-text" id="typingText"></div>
          <div class="cursor"></div>
        </div>
        <div class="hint">
          Type letters and press <strong>Space</strong> or <strong>Enter</strong> to submit.<br />
          Hit tiles just before they cross the bottom line for best timing.
        </div>
      </div>

      <div class="level-editor-hint">
        <strong>Editing levels & notes</strong><br />
        Open <code>index.html</code> and look for the <code>LEVELS</code> array in the script.<br />
        Each tile is:<br />
        <code>{ time: seconds, word: "text", note: "C4" }</code><br />
        Add, remove or change entries to create your own songs.
      </div>
    </div>
  </div>

  <script>
    /**********************************************************
     * 1. CONFIGURATION: LEVELS & NOTES
     **********************************************************/

    const NOTE_FREQUENCIES = {
      "C4": 261.63,
      "D4": 293.66,
      "E4": 329.63,
      "F4": 349.23,
      "G4": 392.00,
      "A4": 440.00,
      "B4": 493.88,
      "C5": 523.25
    };

    // --- LONGER LEVELS ADDED HERE ---
    const LEVELS = [
      {
        id: "demo1",
        name: "Warmup (slow)",
        fallDuration: 4.5,
        tiles: [
          { time: 1.0, word: "la",     note: "C4" },
          { time: 2.5, word: "la",     note: "D4" },
          { time: 4.0, word: "la",     note: "E4" },
          { time: 5.5, word: "play",   note: "G4" },
          { time: 7.0, word: "music",  note: "C5" },
          { time: 9.0, word: "type",   note: "E4" },
          { time: 11.0, word: "piano", note: "G4" }
        ]
      },
      {
        id: "flow1",
        name: "Long Practice – Flow",
        fallDuration: 3.8,
        tiles: [
          { time: 1.0,  word: "type",   note: "C4" },
          { time: 1.8,  word: "flow",   note: "D4" },
          { time: 2.6,  word: "beat",   note: "E4" },
          { time: 3.4,  word: "time",   note: "G4" },
          { time: 4.2,  word: "keys",   note: "A4" },
          { time: 5.0,  word: "rhythm", note: "G4" },

          { time: 6.0,  word: "type",   note: "C4" },
          { time: 6.8,  word: "type",   note: "D4" },
          { time: 7.6,  word: "type",   note: "E4" },
          { time: 8.4,  word: "go",     note: "G4" },
          { time: 9.2,  word: "fast",   note: "A4" },
          { time: 10.0, word: "now",    note: "G4" },

          { time: 11.0, word: "left",   note: "E4" },
          { time: 11.8, word: "right",  note: "D4" },
          { time: 12.6, word: "up",     note: "C4" },
          { time: 13.4, word: "down",   note: "E4" },
          { time: 14.2, word: "jump",   note: "G4" },
          { time: 15.0, word: "tap",    note: "A4" },

          { time: 16.0, word: "focus",  note: "C4" },
          { time: 16.8, word: "stay",   note: "D4" },
          { time: 17.6, word: "in",     note: "E4" },
          { time: 18.4, word: "the",    note: "F4" },
          { time: 19.2, word: "zone",   note: "G4" },
          { time: 20.0, word: "now",    note: "A4" },

          { time: 21.0, word: "home",   note: "E4" },
          { time: 21.8, word: "row",    note: "D4" },
          { time: 22.6, word: "asdf",   note: "C4" },
          { time: 23.4, word: "jkl;",   note: "E4" },
          { time: 24.2, word: "type",   note: "G4" },
          { time: 25.0, word: "smooth", note: "A4" },

          { time: 26.0, word: "flow",   note: "C4" },
          { time: 26.8, word: "flow",   note: "D4" },
          { time: 27.6, word: "flow",   note: "E4" },
          { time: 28.4, word: "more",   note: "G4" },
          { time: 29.2, word: "more",   note: "A4" },
          { time: 30.0, word: "done",   note: "C5" }
        ]
      },
      {
        id: "arpeggio1",
        name: "Long Practice – Arpeggios",
        fallDuration: 3.2,
        tiles: [
          { time: 0.8,  word: "do",   note: "C4" },
          { time: 1.4,  word: "mi",   note: "E4" },
          { time: 2.0,  word: "so",   note: "G4" },
          { time: 2.6,  word: "do",   note: "C5" },

          { time: 3.4,  word: "re",   note: "D4" },
          { time: 4.0,  word: "fa",   note: "F4" },
          { time: 4.6,  word: "la",   note: "A4" },
          { time: 5.2,  word: "re",   note: "D4" },

          { time: 6.0,  word: "up",   note: "C4" },
          { time: 6.6,  word: "up",   note: "E4" },
          { time: 7.2,  word: "up",   note: "G4" },
          { time: 7.8,  word: "up",   note: "C5" },

          { time: 8.6,  word: "down", note: "C5" },
          { time: 9.2,  word: "down", note: "G4" },
          { time: 9.8,  word: "down", note: "E4" },
          { time: 10.4, word: "down", note: "C4" },

          { time: 11.2, word: "roll", note: "E4" },
          { time: 11.8, word: "roll", note: "G4" },
          { time: 12.4, word: "roll", note: "C5" },
          { time: 13.0, word: "rest", note: "D4" },

          { time: 14.0, word: "fast", note: "C4" },
          { time: 14.6, word: "fast", note: "E4" },
          { time: 15.2, word: "fast", note: "G4" },
          { time: 15.8, word: "fast", note: "C5" },

          { time: 16.6, word: "clean", note: "A4" },
          { time: 17.2, word: "clean", note: "G4" },
          { time: 17.8, word: "clean", note: "E4" },
          { time: 18.4, word: "clean", note: "C4" },

          { time: 19.4, word: "final", note: "D4" },
          { time: 20.0, word: "run",   note: "F4" },
          { time: 20.6, word: "run",   note: "A4" },
          { time: 21.2, word: "run",   note: "C5" },

          { time: 22.0, word: "done",  note: "C5" },
          { time: 22.6, word: "gg",    note: "G4" },
          { time: 23.2, word: "wp",    note: "E4" },
          { time: 23.8, word: "rest",  note: "C4" }
        ]
      }
    ];

    /**********************************************************
     * 2. AUDIO (Web Audio API)
     **********************************************************/
    let audioCtx = null;

    function ensureAudioContext() {
      if (!audioCtx) {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AudioContext();
      }
    }

    function playNote(noteName, durationSeconds = 0.35) {
      ensureAudioContext();
      const freq = NOTE_FREQUENCIES[noteName] || 440;
      const osc = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();

      osc.type = "sine";
      osc.frequency.value = freq;

      osc.connect(gainNode);
      gainNode.connect(audioCtx.destination);

      const now = audioCtx.currentTime;
      gainNode.gain.setValueAtTime(0.18, now);
      gainNode.gain.exponentialRampToValueAtTime(0.0001, now + durationSeconds);

      osc.start(now);
      osc.stop(now + durationSeconds + 0.05);
    }

    /**********************************************************
     * 3. GAME STATE
     **********************************************************/
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const scoreDisplay = document.getElementById("scoreDisplay");
    const missDisplay = document.getElementById("missDisplay");
    const speedDisplay = document.getElementById("speedDisplay");
    const typingTextEl = document.getElementById("typingText");
    const levelSelect = document.getElementById("levelSelect");
    const startBtn = document.getElementById("startBtn");
    const pauseBtn = document.getElementById("pauseBtn");

    let currentLevel = LEVELS[0];
    let startTime = null;          // timestamp from requestAnimationFrame
    let paused = false;
    let pauseOffset = 0;           // total paused time
    let pauseStartTime = null;

    let activeTiles = [];
    let remainingTiles = [];
    let score = 0;
    let misses = 0;
    let currentInput = "";

    let lastGameTime = 0;          // for delta timing (pop effect)

    const tileWidth = 150;
    const tileHeight = 40;
    const bottomLineY = canvas.height - 40;

    /**********************************************************
     * 4. INITIALIZATION
     **********************************************************/
    function populateLevelSelect() {
      LEVELS.forEach((level, index) => {
        const opt = document.createElement("option");
        opt.value = level.id;
        opt.textContent = level.name;
        if (index === 0) opt.selected = true;
        levelSelect.appendChild(opt);
      });
    }

    function resetGame(level) {
      currentLevel = level || currentLevel;
      startTime = null;
      pauseOffset = 0;
      pauseStartTime = null;
      paused = false;
      lastGameTime = 0;

      activeTiles = [];
      remainingTiles = currentLevel.tiles
        .map(t => ({ ...t, spawned: false }))
        .sort((a, b) => a.time - b.time);

      score = 0;
      misses = 0;
      currentInput = "";
      updateTypingDisplay();
      updateStatusDisplays();
      speedDisplay.textContent = currentLevel.fallDuration <= 3 ? "Fast" :
                                 currentLevel.fallDuration >= 4.5 ? "Slow" :
                                 "Normal";
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawFrame(0);
    }

    populateLevelSelect();
    resetGame(LEVELS[0]);

    /**********************************************************
     * 5. GAME LOOP
     **********************************************************/
    function getGameTimeSeconds(timestamp) {
      if (startTime === null) return 0;
      return (timestamp - startTime - pauseOffset) / 1000;
    }

    function spawnTiles(gameTime) {
      while (remainingTiles.length > 0 && remainingTiles[0].time <= gameTime) {
        const base = remainingTiles.shift();
        const laneCount = 4;
        const laneIndex = activeTiles.length % laneCount;
        const laneWidth = canvas.width / laneCount;
        const x = laneIndex * laneWidth + (laneWidth - tileWidth) / 2;

        activeTiles.push({
          word: base.word,
          note: base.note,
          spawnTime: gameTime,
          x,
          y: -tileHeight,
          hit: false,
          missed: false,
          state: "falling",      // "falling" | "popping" | "done"
          effectProgress: 0
        });
      }
    }

    function updateTiles(gameTime, delta) {
      const duration = currentLevel.fallDuration;

      activeTiles.forEach(tile => {
        if (tile.state === "falling") {
          const t = Math.max(0, Math.min(1, (gameTime - tile.spawnTime) / duration));
          tile.y = t * (bottomLineY - tileHeight);

          if (!tile.hit && !tile.missed && tile.y + tileHeight >= bottomLineY + 4) {
            tile.missed = true;
            tile.state = "popping";
            tile.effectProgress = 0;
            misses += 1;
            updateStatusDisplays();
          }
        } else if (tile.state === "popping") {
          tile.effectProgress += delta;
          // keep it around the bottom line while popping
          tile.y = bottomLineY - tileHeight - tile.effectProgress * 40;
          if (tile.effectProgress >= 0.4) {
            tile.state = "done";
          }
        }
      });

      activeTiles = activeTiles.filter(tile => tile.state !== "done");
    }

    function drawFrame(gameTime) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, "#020617");
      gradient.addColorStop(1, "#020617");
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Bottom "hit line"
      ctx.strokeStyle = "#4b5563";
      ctx.lineWidth = 2;
      ctx.setLineDash([6, 6]);
      ctx.beginPath();
      ctx.moveTo(0, bottomLineY);
      ctx.lineTo(canvas.width, bottomLineY);
      ctx.stroke();
      ctx.setLineDash([]);

      // Draw tiles
      activeTiles.forEach(tile => {
        let baseColor = [34, 197, 94]; // green
        let baseFillAlpha = 0.2;
        let baseBorderAlpha = 0.7;

        if (tile.missed && !tile.hit) {
          baseColor = [239, 68, 68]; // red
          baseFillAlpha = 0.22;
          baseBorderAlpha = 0.9;
        } else if (tile.hit) {
          baseColor = [34, 197, 94]; // stronger green
          baseFillAlpha = 0.4;
          baseBorderAlpha = 0.95;
        }

        let scale = 1;
        let fadeAlpha = 1;

        if (tile.state === "popping") {
          const p = Math.min(tile.effectProgress / 0.4, 1); // 0 → 1
          scale = 1 + 0.4 * p;       // grow
          fadeAlpha = 1 - p;         // fade out
        }

        const fillAlpha = baseFillAlpha * fadeAlpha;
        const borderAlpha = baseBorderAlpha * fadeAlpha;

        const x = tile.x;
        const y = tile.y;
        const w = tileWidth;
        const h = tileHeight;
        const centerX = x + w / 2;
        const centerY = y + h / 2;
        const radius = 10;

        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.scale(scale, scale);
        ctx.translate(-centerX, -centerY);

        ctx.fillStyle = `rgba(${baseColor[0]}, ${baseColor[1]}, ${baseColor[2]}, ${fillAlpha})`;
        ctx.strokeStyle = `rgba(${baseColor[0]}, ${baseColor[1]}, ${baseColor[2]}, ${borderAlpha})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + w - radius, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
        ctx.lineTo(x + w, y + h - radius);
        ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
        ctx.lineTo(x + radius, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = "#e5e7eb";
        ctx.font = "bold 16px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(tile.word, x + w / 2, y + h / 2);

        ctx.restore();
      });
    }

    function gameLoop(timestamp) {
      if (paused) {
        requestAnimationFrame(gameLoop);
        return;
      }

      if (startTime === null) {
        startTime = timestamp;
        lastGameTime = 0;
      }

      const gameTime = getGameTimeSeconds(timestamp);
      const delta = Math.max(0, gameTime - lastGameTime);
      lastGameTime = gameTime;

      spawnTiles(gameTime);
      updateTiles(gameTime, delta);
      drawFrame(gameTime);

      requestAnimationFrame(gameLoop);
    }

    /**********************************************************
     * 6. INPUT HANDLING
     **********************************************************/
    function updateTypingDisplay() {
      typingTextEl.textContent = currentInput;
    }

    function submitInput() {
      const word = currentInput.trim().toLowerCase();
      if (!word) return;
      currentInput = "";
      updateTypingDisplay();

      let bestTile = null;
      let bestDist = Infinity;

      activeTiles.forEach(tile => {
        if (tile.hit || tile.missed || tile.state !== "falling") return;
        if (tile.word.toLowerCase() !== word) return;
        const dist = Math.abs((tile.y + tileHeight) - bottomLineY);
        if (dist < bestDist) {
          bestDist = dist;
          bestTile = tile;
        }
      });

      if (bestTile) {
        bestTile.hit = true;
        bestTile.state = "popping";
        bestTile.effectProgress = 0;
        score += 10;
        updateStatusDisplays();
        playNote(bestTile.note);
      }
    }

    function updateStatusDisplays() {
      scoreDisplay.textContent = score;
      missDisplay.textContent = misses;
    }

    window.addEventListener("keydown", (e) => {
      if (e.metaKey || e.ctrlKey || e.altKey) return;

      if (e.key === "Backspace") {
        e.preventDefault();
        currentInput = currentInput.slice(0, -1);
        updateTypingDisplay();
        return;
      }

      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        submitInput();
        return;
      }

      if (e.key.length === 1) {
        currentInput += e.key;
        updateTypingDisplay();
      }
    });

    /**********************************************************
     * 7. BUTTONS & LEVEL CHANGE
     **********************************************************/
    startBtn.addEventListener("click", () => {
      ensureAudioContext();
      resetGame(currentLevel);
      requestAnimationFrame(gameLoop);
    });

    pauseBtn.addEventListener("click", () => {
      if (!startTime) return;

      if (!paused) {
        paused = true;
        pauseStartTime = performance.now();
        pauseBtn.textContent = "Resume";
      } else {
        paused = false;
        if (pauseStartTime !== null) {
          const now = performance.now();
          pauseOffset += now - pauseStartTime;
        }
        pauseStartTime = null;
        pauseBtn.textContent = "Pause";
      }
    });

    levelSelect.addEventListener("change", (e) => {
      const id = e.target.value;
      const level = LEVELS.find(l => l.id === id);
      if (level) {
        resetGame(level);
      }
    });
  </script>
</body>
</html>
